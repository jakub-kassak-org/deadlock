# deadlock-server

This API is developed using [FastAPI](https://fastapi.tiangolo.com/).

### How to setup locally

#### Python version and requirements
Create a `python3.7` virtual enviroment and activate it.
Install requirements using `pip install -r requirements.txt`. 

#### Starting a DB and providing testing data
Start a Postgres server locally. Create a database called `test` owned by user `test`.
Now let's fill the data from `fixtures.sql` into the database. Run those from terminal:
```
su test
psql
```
The Postgres console should start up. Execute those commands in it to reset it:
```sql
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;
```
Exit Postgres console.
Now run `python main.py` to let it create tables.
After a few seconds, `main.py` should finish creating tables. Let's fill testing
data into the database:
```
psql -f fixtures.sql
```

#### Run the server
```
uvicorn main:app --reload
```

### How to log
Logging configuration is in `logging.conf`.
There are 3 loggers in `main.py`.

First of them is `access_logger`, which is used
for access logs into a file (`access.log`).

Access logging happens in `/entry/eval/` endpoint. Log file shows a pair
`(card_number, access_point_id)` in every log.

Second of them, `root_logger` can be used to print to `stdout`. One can use
`root_logger.info('message to print to stdout')` for this.

Third of them is `runtime_logger`, which is used
for runtime logs, such as runtime exceptions. It
logs into a file (`runtime.log`).

## Interaction with API

### Superuser

Most endpoints require superuser rights. There is a staff user with username
`stlpik` and password `secret`. It was inserted into the database from `fixtures.sql`.
This user should be allowed to fully interact with the API. 

### How to get access token (jwt)
Send `POST` request to `/token/` with body like:
```json
{
        "username": "name",
        "password": "verysecretpassword"
}
```

### Other endpoints

There is an interactive documentation generated by `FastAPI` accessible on `http://localhost:8000/docs`.
It is possible to send requests and receive responses directly from the docs for testing
and debugging purposes. 

#### `[GET] /users/`
Returns list of users in json format:
```json
{
  "users": [
    {
      "username": "stlpik",
      "first_name": "Meno",
      "is_staff": true,
      "disabled": false,
      "updated": "2020-12-18T18:27:34.783243",
      "id": 1,
      "card": "1234567891011",
      "last_name": "Priezvisko",
      "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
      "created": "2020-12-18T18:27:34.783243"
    },
    {
      "username": "stud",
      "first_name": "Meno",
      "is_staff": false,
      "disabled": false,
      "updated": "2020-12-18T18:27:34.783243",
      "id": 2,
      "card": "1234567891011",
      "last_name": "Priezvisko",
      "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
      "created": "2020-12-18T18:27:34.783243"
    }
  ]
}
```

#### `[POST] /users/`
Adds a new user to the database. Fields username and card are unique.
Request body example:
```json
{
  "card": "9876543210",
  "username": "newusername",
  "first_name": "SomeFirst",
  "last_name": "SomeLast",
  "is_staff": true
}
```
Corresponding response body example:
```json
{
  "card": "9876543210",
  "username": "newusername",
  "first_name": "SomeFirst",
  "last_name": "SomeLast",
  "is_staff": true,
  "id": "6",
  "disabled": false,
  "groups": [],
  "created": "2021-01-21T14:32:53.699616",
  "updated": "2021-01-21T14:32:53.699616"
}
```

#### `[DELETE] /users/delete/{user_id}/`
Deletes user with `id = user_id`. Example response:
```json
{
  "was_deleted": true,
  "detail": "success",
  "id": 2
}
```

#### `[PUT] /users/update/{user_id}/`
Updates a user with `id = user_id`. Gets all data just like when creating user
(`UserCreate` schema in `db/schemas.py`)

Example request:
```json 
{
  "card": "123456789",
  "username": "new_username",
  "first_name": "OriginalFirst",
  "last_name": "OriginalLast",
  "is_staff": false
}
```

Success response:
```json
{
  "was_updated": true,
  "detail": "success",
  "id": 4
}
```

#### `[GET] /users/me/`
Gets current user:
```json
{
  "first_name": "Meno",
  "username": "stlpik",
  "is_staff": true,
  "disabled": false,
  "updated": "2021-03-12T19:30:41.255382",
  "id": 1,
  "card": "1234567891011",
  "last_name": "Priezvisko",
  "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
  "created": "2021-03-12T19:30:41.255382"
}
```

#### `[GET] /groups/`
Returns list of all groups like this:
```json
{
  "groups": [
    {
      "name": "LinuxPP",
      "updated": "2021-01-21T14:05:28.812339",
      "created": "2021-01-21T14:05:28.812339",
      "id": 1
    },
    {
      "name": "SkupinaNejaka",
      "updated": "2021-01-21T16:01:27.324223",
      "created": "2021-01-21T16:01:27.324223",
      "id": 2
    }
  ]
}
```

#### `[POST] /groups/`
Creates a group.
Request example:
```json
{
  "name": "newgroup"
}
```
Response example:
```json
{
  "id": 0,
  "name": "newgroup",
  "rules": []
}
```
where `rules` contains ids of rules that are applied for this group, which is initially
empty after creating the group. `[POST] /groups/{group_id}/change_ruleset/` could
be used to modify rules of the group afterwards.

#### `[GET] /groups/{group_id}/`
Gets list of users belonging to group with id `{group_id}`.
Example response to `GET` from `/groups/2`:
```json
{
  "group_id": 2,
  "users": [
    {
      "username": "stlpik",
      "first_name": "Meno",
      "is_staff": true,
      "disabled": false,
      "updated": "2021-01-21T14:05:28.795202",
      "id": 1,
      "card": "1234567891011",
      "last_name": "Priezvisko",
      "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
      "created": "2021-01-21T14:05:28.795202"
    },
    {
      "username": "stud",
      "first_name": "Meno",
      "is_staff": false,
      "disabled": false,
      "updated": "2021-01-21T14:05:28.795202",
      "id": 2,
      "card": "1234567891012",
      "last_name": "Priezvisko",
      "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
      "created": "2021-01-21T14:05:28.795202"
    }
  ]
}
```

#### `[DELETE] /groups/delete/{group_id}/`
Deleted a group with `id = group_id`. Response similar to the one described
in `/users/delete/{user_id}/`

#### `[PUT] /groups/update/{group_id}/`
Updates a group with `id = group_id`. Gets only name, just like when creating a group.
(`GroupCreate` schema in `db/schemas.py`). This is not for updating group's rules.
For assigning rules to the group, use TODO instead.

Example request:
```json 
{
  "name": "new_group_name",
}
```

Success response:
```json
{
  "was_updated": true,
  "detail": "success",
  "id": 1
}
```

#### `[POST] /groups/{group_id}/change_ruleset/`
Modifies a ruleset of the group with `id=group_id`. Takes two sets of ids.
First of them is `include_rules_ids`, which says what rules should be added for the
group. Second of them is `exclude_rules_ids`, which says what rules should be
removed from the rules. It the same id is in both `include_rules_ids` and `exclude_rules_ids`,
it will not be included in the final ruleset.

Let the ids of rules originally in the ruleset be `original_rules_ids`. The reusulting
ruleset is calculated as `(original_rules_ids + include_rules_ids) - exclude_rules_ids`,
where `+` stands for set union and `-` stands for set difference.

Example request (`group_id` goes to the URL):
```json
{
  "include_rules_ids": [3, 6],
  "exclude_rules_ids": [1, 2]
}
```

Success response example:
```json
{
  "updated": true,
  "detail": "success",
  "id": 1
}
```

#### `[GET] /groups/by_ap_type_and_time_spec/`
Given `ap_type_id` and `time_spec_id` (mandatory query parameters),
returns a list of group names, that use access points
of that `AccessPointType` during the time specified by `TimeSpec`. Rules are searched and filtered
using the `TimeSpec` and `AccessPointType`, so the `TimeSpec` has to match the one in rule exactly.
Therefore, rules with `TimeSpec` that is _superset_ of the given one won't be matched and
groups with those rules won't be included in a response, unless an exact rule for that group is found.

To get an `time_spec_id` from weekday and time range, one can use the `/timespec/get_ids/` endpoint,
if needed.

Example response:
```json
{
  "groups": [
    {
      "id": 1,
      "name": "Linux PP"
    }
  ]
}
```

#### `[POST] /usergroup/add/`
Adds a user with with id `user_id` to the group with id `group_id`.
Just make `POST` request to address like `/usergroup/add/?user_id=3&group_id=1`.

Success response looks like:
```json
{
  "id": 5,
  "user_id": 3,
  "group_id": 1
}
```

#### `[DELETE] /usergroup/delete/{user_id}/{group_id}/`
Removes a user with `id = user_id` from the group with `id = group_id`.
Success response example:
```json
{
  "id": 1,
  "user_id": 1,
  "group_id": 1,
  "was_deleted": true
}
```

#### `[POST] /rules/add/`
Adds a rule. Does not assign it to groups yet.

Example request:
```json
{
  "name": "1INFComputerRooms",
  "allow": true,
  "time_spec_id": 1,
  "ap_type_id": 2,
  "priority": 6
}
```

Example response:
```json
{
  "name": "1INFComputerRooms",
  "allow": true,
  "time_spec_id": 1,
  "ap_type_id": 2,
  "priority": 6
}
```

#### `[DELETE] /rules/delete/{rule_id}/`
Deletes a rule with `id = rule_id`. Success response similar to the one
described in `/usergroup/delete/{user_id}/{group_id}/`.

#### `[POST] /timespec/add/`
Adds a time specification. Attribute `weekday_mask` works as follows.
Days are numbered `0` through `6` inclusively, where `0` is Monday and `6` is Sunday.
If day number `i` should be affected by this time specification, then it needs to be
set using `weekday_mask`. Day number `i` is affected iff `weekday_mask & (1 << i)`.
For example, time specification affecting Tuesday and Friday has `weekday_mask` of
`0010010` in binary, where least significant bit is last. This needs to be converted to
decimal, therefore, value of `weekday_mask` for Tuesday and Friday should be `18`.
Attributes `date_from` and `date_to` mark the beginning and the end of time period during
which this time specification is valid. Attributes `time_from` and `time_to` express
time period during which this time specification si valid during days specified by
`weekday_mask`.

Example request body:
```json
{
  "title": "MondayMorning",
  "weekday_mask": 1,
  "time_from": "06:00:00.000",
  "time_to": "09:00:00.000",
  "date_from": "2021-01-22 00:00:00.000",
  "date_to": "2022-01-22 00:00:00.000"
}
```

Example response:
```json
{
  "title": "MondayMorning",
  "weekday_mask": 1,
  "time_from": "06:00:00",
  "time_to": "09:00:00",
  "date_from": "2021-01-22T00:00:00",
  "date_to": "2022-01-22T00:00:00",
  "id": 4
}
```

#### `[DELETE] /timespec/delete/{time_spec_id}/`
Deletes the `TimeSpec` with `id = time_spec_id`.
Success response example:
```json
{
  "was_deleted": true,
  "detail": "success",
  "id": 2
}
```

#### `[GET] /timespec/get_ids/`
Gets a list of `TimeSpec` `id`s, that exactly match `weekday`, `time_from` and `time_to`.
Does not take `date_from` and `date_to` into account, but returns information about
those dates.

Takes mandatory query parameters of `weekday` (0-6, where 0 = Monday), `time_from` (string of `hh:mm`)
and `time_to` (string of `hh:mm`).

Response example:
```json
[
  {
    "id": 1,
    "weekday_mask": 31,
    "time_from": "17:00:00",
    "time_to": "22:00:00",
    "date_from": "2021-03-12T19:48:16.104465",
    "date_to": "2022-01-01T00:00:00"
  }
]
```


#### `[GET] /aptype/`
Gets a list of all access point types. Check the description of `/aptype/add/` for
the use case of aptype.


#### `[POST] /aptype/add/`
Adds access point type. This is good for rules that need to affect multiple doors that need
similar level of security.

Example request:
```json
{
  "name": "ComputerRooms"
}
```

Example response:
```json
{
  "name": "ComputerRooms",
  "id": 2,
  "created": "2021-01-22T18:27:28.322909",
  "updated": "2021-01-22T18:27:28.322909"
}
```

#### `[DELETE] /aptype/delete/{ap_type_id}/`
Deletes an `AccessPointType` with `id = ap_type_id`.
Success response is similar to the one in `/timespec/delete/{time_spec_id}/`.


#### `[PUT] /aptype/{aptype_id}/add_aps/`
Assigns the `AccessPointType` with `id=aptype_id` to all of the
`AccessPoint`s specified by the request body.

This is the inverse operation of `/aptype/{aptype_id}/remove_aps/`.

Example request body:
```json
[1, 2]
```

Success response example (after putting to `/aptype/2/add_aps/`):
```json
{
  "success": true,
  "id": 2
}
```


#### `[PUT] /aptype/{aptype_id}/remove_aps/`
Remove the `AccessPoint`s specified by the body from the
`AccessPointType` with `id=aptype_id`.

This is the inverse operation of `/aptype/{aptype_id}/add_aps/`.

Example request body:
```json
[1, 2]
```

Success response example (after putting to `/aptype/2/remove_aps/`):
```json
{
  "success": true,
  "id": 2
}
```